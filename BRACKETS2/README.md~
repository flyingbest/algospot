큐와 스택, 데크
====

### 큐와 스택, 데크

큐와 스택, 데크는 일렬로 늘어선 같은 형태의 자료들을 저장.

이때 세 자료를 구분하는 것은 어느 쪽 끝에서 자료를 넣고 뺄 수 있는가.

- 큐(queue) - FIFO(First In First Out)
- 스택(stack) - LIFO(Last In First Out)
	컴퓨터는 내부적으로 스택을 사용해 함수들의 문맥(context)를 관리.
- 데크(dequeue) - 양쪽 끝에서 자료들을 넣고 뺄 수 있는 자료 구조.
	데크를 사용하면 스택과 큐를 모두 구현 가능.

자료구조에 자료를 넣은 작업 - PUSH(푸시), 자료를 빼는 작업 - POP(팝).

이들 연산은 모두 상수 시간, 즉 O(1)에 이루어져야 한다.

### 구현

>연결 리스트를 통한 구현

가장 간단한 방법은 연결 리스트를 사용하는 것.
연결 리스트를 이용하면 양쪽 끝에서의 추가와 삭제를 모두 상수 시간에 할 수 있기 때문에, 
모든 연산이 상수 시간이어야 한다는 요구조건을 쉽게 충족.
하지만 이 경우 노드의 할당과 삭제 그리고 포인터를 따라가는데 드는 시간이 걸리기 때문에 연결 리스트가 가장 효율적인 구현은 아니다.

> 동적 배열을 이용한 구현

스택의 경우에는 한쪽 끝에서만 자료의 추가와 삭제가 일어나므로 동적 배열을 곧장 사용할 수 도 있지만, 큐와 데크의 경우 뒤에서 원소를
추가하거나 삭제하기는 쉽지만 배열의 맨 앞에서 원소를 삭제하기 위해서는 O(n)의 시간이 걸린다.

-> 원리와 방법 설명 추가

>표준 라이브러리의 구현

아주 기본적인 자료구조이기 때문에 거의 도든 언어의 표준 라이브러리에서 구현체를 제공. 이런 기초 자료구조를 직접 구현하느라 소중한 시간을 낭비 that's nono!

### 스택과 큐의 활용

>큐를 이용한 josephus problem

죽을 사람을 가리키는 포인터를 옮기는 대신 사람들을 움직인다. 그러면 다음 과정을 큐에 두 명이 남을 때가지 반복해서 문제를 풀 수 있다.
```
- 큐의 첫 번째 사람이 나와서 죽고
- 큐의 맨 앞에 있는 사람을 맨 뒤로 보내는 작업을 k-1번 반복.
```
큐에서 원소의 추가와 삭제는 각각 상수시간에 이루어지기 때문에 이 알고리즘의 수행시간 또한 연결리스트를 사용한 것과 같다.

>스택을 이용한 울타리 자르기 문제

