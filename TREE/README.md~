트리(Tree)
=====

### 일반적 트리 구조 (트리의 구현과 순회)

#### 도입

계층적 구조를 갖는 자료들을 표현하기 위한 자료 구조가 바로 트리(tree).

트리는 처음에 이와 같이 현실 세계의 개념을 추상화해 표현하는 자료구조로 고안.
하지만 탐색형 자료 구조로도 유용.

> 트리의 구성요소

- 자료가 저장된 노드(node)들이 간선(edge)으로 서로 연결되어 있는 자료 구조 = 트리
- 노드간에는 상/하위 관계 존재.
- 두 연결된 노드 중 상위 노드 = 부모(parent), 하위 노드 = 자식(child) 노드.
- 부모 노드가 같은 두 노드는 형제(sibling) 노드.
- 부노 노드와 그의 부모들을 통틀어 선조(ancestor).
- 자식 노드와 그의 자식들을 통틀어 자손(descendant).
- 한 노드는 여러 개의 자식을 가질 수 있어도 부모는 하나만 가질 수 있다.
- 다른 모든 노드들을 자손으로 갖는 노드가 딱 하나 = 루트(root).
- 반대로 자식이 하나도 없는 노드들을 트리의 잎 노드 혹은 리프(leaf).

> 트리와 노드의 속성

- 루트에서 어떤 노드에 도달하기 위해 거쳐야 하는 간선의 수 = 해당 노드의 깊이(depth).
	깊이가 깊을 수록 트리 아래쪽에 있는 노드를 지칭.
- 트리에서 가장 깊숙히 있는 노드의 깊이를 해당 트리의 높이(height).

**질문!!! 그럼 깊이나 높이가 같은건가?**

> 트리의 재귀적 속성

- 어떤 노드 t와 그 자손들로 구성된 트리를 't를 루트로 하는 서브트리(subtree)'.
- 따라서 모든 트리는 루트와 루트 밑에 있는 서브트리들의 집합.
- 이와 같은 재귀적 속성 때문에 트리를 다루는 코드들은 대개 재귀 호출을 이용해 구현.

> 트리의 표현

- 일반적인 형태 : 각 노드를 하나의 구조체/객체로 표현하고, 이들을 서로의 포인터로 연결.

트리의 노드를 표현하는 객체의 구현
```
struct TreeNode{
	string label;	// 저장할 자료(물론 꼭 문자열일 필요는 없다.)
	TreeNode* parent;	// 부모 노드를 가리키는 포인터
	vector<TreeNode*> children;	// 자손 노드들을 가리키는 포인터의 배열
};
```

#### 트리의 순회

트리는 구조가 일정하지 않기 때문에 포함된 모든 자료들을 순회하기 어려움.
쉽게 하기 위해서는 트리의 재귀적 속성을 이용!

트리를 순회하며 모든 노드에 포함된 값을 출력.
```
// 주어진 트리의 각 노드에 저장된 값을 모두 출력.
void printLabels(TreeNode* root){
	// 루트에 저장된 값을 출력.
	cout << root->label << endl;
	// 각 자손들을 루트로 하는 서브트리에 포함된 값들을 재귀적으로 출력.
	for(int i=0; i<root->children.size(); ++i)
		printLabels(root->children[i]);
}
```

순회를 이용해 트리의 높이를 계산.
```
// root를 루트로 하는 트리의 높이를 구한다.
int height(TreeNode* root){
	int h = 0;
	for(int i=0; i<root->children.size(); ++i)
		h = max(h, 1 + height(root->children[i]));
	return h;
}
```

트리에 n개의 노드가 있다고 하면 이들을 모두 순회하기 위해서는 O(n)의 시간이 들어야 정상.

>> TRAVERSAL 문제



### 이진 검색 트리

### 우선 순위 큐, 힙의 구현

### 구간 트리

### 유니온-파인드 자료구조

### 트라이
