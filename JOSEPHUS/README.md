선형 자료 구조
==============
### 참고 사이트

		http://www.hanbit.co.kr/network/view.html?bi_id=1585

배열의 큰 문제중 하나 : 처음에 선언한 배열의 크기 이상의 자료를 넣을 수 없다.

### 동적배열 (Dynamic Array)

일반 배열처럼 언어 차원에서 지원되는 기능이 아니라 배열을 이용해 만든 별도의 자료구조

>본래 배열의 특징

 - 원소들은 메모리의 연속된 위치에 저장된다.
 - 주어진 위치의 원소를 반환하거나 변경하는 동작을 O(1)에 할 수 있다.
 
>동적배열이 갖는 추가 특성

 - 배열의 크기를 변경하는 resize() 연산이 가능. 이동작을 수행하는데 배열의 크기 N에 비례하는 시간 소요.
 - 주어진 원소를 배열의 맨 끝에 추가함으로써 크기를 1늘리는 append() 연산을 지원. 이 동작을 수행하는데 상수시간 소요.
 
동적 배열의 크기가 바뀌어야 할 때는 단순하게 새 배열을 동적으로 할당받은 뒤 기존 원소들을 복사하고, 새 배열을 참조하도록 바꿔치기 합니다.
따라서 동적 배열 클래스는 현재 배열의 크기와 동적으로 할당받은 배열을 가리키는 포인터를 다음과 같이 저장하고 있을 것이다.

```
int size;	//배열의 크기
ElementType** array;	//실제 배열을 가리키는 포인터
```

새 배열을 할당받고 기존 자료를 복사하는 데는 배열의 크기에 비례하는 시간 소요.
이와 같은 방법을 이용하면 resize() 연산을 O(N)에 구현한다는 요구 조건을 쉽게 만족.
문제는 append()가 연산을 어떻게 상수시간에 구하느냐!
append()가 호출될 때마다 resize()를 호출해서는 append()의 수행시간도 선형시간이 되어버린다.

**메모리를 할당받을 때 배열의 크기가 커질 때를 대비해서 여유분의 메모리를 할당받아 두는 것!**

**배열이 이미 할당한 메모리에 꽉 찼을 때 더 큰 메모리를 할당받아 배열의 원소를 그 쪽으로 전부 옮기는 것!**

예를 들어, 8비트의 메모리 크기를 할당받았다고 하자. Capacity = 8;

거기에 실제원소를 6,6,6,8,5,3 순으로 6bit를 채워넣었다. 실제원소의 수를 배열의 크기라 한다. Size = 6;
	
동적배열의 내부에서는 배열의 크기가 커지는 것에 대비해 여유분의 메모리를 확보하고 있지만, 실제로 동적 배열을 사용하는 프로그램에서는 배열의 크기(6)로 인식한다.
따라서 동적 배열은 현재 배열의 크기와 배열이 현재 저장된 메모리 내의 위치 외에도 용량을 함께 저장해야 한다.
만약 용량보다 작다면 append() 연산은 size를 1 늘리고 그 위치에 새 값을 할당하는 것으로 구현.

```
// append(newValue)의 일부
array[size++] = newValue;
```

이 과정은 상수시간에 구현 가능.
만약 메모리가 꽉 찼을 경우(capacity가 8인데 size도 8일 때), append()연산을 하기 위해 더 큰 새 배열을 동적으로 할당받고 새 배열에 기존 배열의 내용을 모두 복사한 다음 배열에 대한 포인터를 바꿔치기해야 한다.
이 과정을 재할당이라고 한다.

```
// 배열 용량이 꽉 찼으면 재할당받는다.
if(size == capacity){
	// 용량을 M만큼 늘린 새 배열을 할당받는다.
	int newCapacity = capacity + M;
	int *newArray = new int[newCapacity];
	// 기존의 자료를 복사한다.
	for(int i=0; i<size; ++i)
		newArray[i] = array[i];
	// 기존 배열을 삭제하고, 새 배열로 바꿔치기 한다.
	if(array) delete [] array;
	array = newArray;
	capacity = newCapacity;
}
// 배열의 끝에 원소를 삽입한다.
array[size++] = newValue;
```

위 코드는 배열이 꽉 찼을 때 미리 정해놓은 M이라는 크기만큼 배열의 용량을 늘려준다.
이 재할당 과정에 드는 시간은 O(N+M).

