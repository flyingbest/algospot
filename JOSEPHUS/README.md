선형 자료 구조
==============
### 참고 사이트

- http://www.hanbit.co.kr/network/view.html?bi_id=1585

배열의 큰 문제중 하나 : 처음에 선언한 배열의 크기 이상의 자료를 넣을 수 없다.

### 동적배열 (Dynamic Array)

일반 배열처럼 언어 차원에서 지원되는 기능이 아니라 배열을 이용해 만든 별도의 자료구조

>본래 배열의 특징

 - 원소들은 메모리의 연속된 위치에 저장된다.
 - 주어진 위치의 원소를 반환하거나 변경하는 동작을 O(1)에 할 수 있다.
 
>동적배열이 갖는 추가 특성

 - 배열의 크기를 변경하는 resize() 연산이 가능. 이동작을 수행하는데 배열의 크기 N에 비례하는 시간 소요.
 - 주어진 원소를 배열의 맨 끝에 추가함으로써 크기를 1늘리는 append() 연산을 지원. 이 동작을 수행하는데 상수시간 소요.
 
동적 배열의 크기가 바뀌어야 할 때는 단순하게 새 배열을 동적으로 할당받은 뒤 기존 원소들을 복사하고, 새 배열을 참조하도록 바꿔치기 합니다.
따라서 동적 배열 클래스는 현재 배열의 크기와 동적으로 할당받은 배열을 가리키는 포인터를 다음과 같이 저장하고 있을 것이다.

```
int size;	//배열의 크기
ElementType** array;	//실제 배열을 가리키는 포인터
```

새 배열을 할당받고 기존 자료를 복사하는 데는 배열의 크기에 비례하는 시간 소요.
이와 같은 방법을 이용하면 resize() 연산을 O(N)에 구현한다는 요구 조건을 쉽게 만족.
문제는 append()가 연산을 어떻게 상수시간에 구하느냐!
append()가 호출될 때마다 resize()를 호출해서는 append()의 수행시간도 선형시간이 되어버린다.

**메모리를 할당받을 때 배열의 크기가 커질 때를 대비해서 여유분의 메모리를 할당받아 두는 것!**

**배열이 이미 할당한 메모리에 꽉 찼을 때 더 큰 메모리를 할당받아 배열의 원소를 그 쪽으로 전부 옮기는 것!**

예를 들어, 8비트의 메모리 크기를 할당받았다고 하자. Capacity = 8;

거기에 실제원소를 6,6,6,8,5,3 순으로 6bit를 채워넣었다. 실제원소의 수를 배열의 크기라 한다. Size = 6;
	
동적배열의 내부에서는 배열의 크기가 커지는 것에 대비해 여유분의 메모리를 확보하고 있지만, 실제로 동적 배열을 사용하는 프로그램에서는 배열의 크기(6)로 인식한다.
따라서 동적 배열은 현재 배열의 크기와 배열이 현재 저장된 메모리 내의 위치 외에도 용량을 함께 저장해야 한다.
만약 용량보다 작다면 append() 연산은 size를 1 늘리고 그 위치에 새 값을 할당하는 것으로 구현.

```
// append(newValue)의 일부
array[size++] = newValue;
```

이 과정은 상수시간에 구현 가능.
만약 메모리가 꽉 찼을 경우(capacity가 8인데 size도 8일 때), append()연산을 하기 위해 더 큰 새 배열을 동적으로 할당받고 새 배열에 기존 배열의 내용을 모두 복사한 다음 배열에 대한 포인터를 바꿔치기해야 한다.
이 과정을 재할당이라고 한다.

```
// 배열 용량이 꽉 찼으면 재할당받는다.
if(size == capacity){
	// 용량을 M만큼 늘린 새 배열을 할당받는다.
	int newCapacity = capacity + M;
	int *newArray = new int[newCapacity];
	// 기존의 자료를 복사한다.
	for(int i=0; i<size; ++i)
		newArray[i] = array[i];
	// 기존 배열을 삭제하고, 새 배열로 바꿔치기 한다.
	if(array) delete [] array;
	array = newArray;
	capacity = newCapacity;
}
// 배열의 끝에 원소를 삽입한다.
array[size++] = newValue;
```

위 코드는 배열이 꽉 찼을 때 미리 정해놓은 M이라는 크기만큼 배열의 용량을 늘려준다.
이 재할당 과정에 드는 시간은 O(N+M).

append()를 호출할 때마다 항상 선형 시간이 걸리는 것은 아니다. append()를 수행하는데 선형 시간이 걸리는 것은 아주 가끔 일어나는 재할당 과정 때문이다.
이렇게 호출할 때마다 수행 시간이 달라지는 함수의 시간 복잡도를 계산하는 방법 중 하나는 연산을 아주 여러 번 반복해 수행한 뒤 각 수행시간의 평균을 구하는 것.

### 연결 리스트

배열 원소들의 순서를 유지하면서 임의의 위치에 원소를 삽입하거나, 삭제하는 것은 시간이 오래 걸리는 작업이다.
해당 위치 뒤에 있는 원소들을 하나씩 뒤칸 혹은 앞칸으로 옮겨야 하기 때문!

연결 리스트는 특정 위치에서의 삽입과 삭제를 상수시간에 할 수 있게 해준다.

배열에서는 메모리의 연속된 위치에 각 원소들이 저장되어 있다면, 연결리스트는 원소들이 메모리 여기저기 흩어져 있고 각 원소들이 이전과 다음 원소를 가리키는 포인터를 가지고 있는 방식.

예를 들어, 정수를 담는 연결 리스트는 다음과 같은 노드 구조체 사용해 구현
```
struct ListNode {
	int element;	// 담고 있는 원소
	ListNode *prev, *next;	// 이전 노드, 다음 노드의 포인터
};
```
정확하게는 이와 같은 연결 리스트를 양방향 연결 리스트(doubly linked list)이다. 각 원소가 이전과 다음 원소에 대한 정보를 모두 가지고 있는 양방향 연결 리스트와 달리,
단방향 연결 리스트(singly linked list)에서는 각 원소가 다음 원소를 가리키는 포인터만 가지고 있다.

>연결 리스트 다루기

배열과 달리 연결 리스트에서는 메모리 여기저기에 노드들이 흩어져 있기 때문에 특정 위치의 값을 찾기 어렵다. 연결 리스트에서 i번째 노드를 찾아내려면 리스트의 머리에서부터 시작해 
하나씩 포인터를 따라가며 다음 노드를 찾는 수밖에 없다. 결과적으로 i번째 노드를 찾는 데 드는 시간은 리스트 길이에 선형 비례한다.
반면 노드를 삽입하거나 삭제하는 작업은 포인터만 변경하면 되기 때문에 상수 시간에 이루어진다.

>삭제했던 원소 돌려놓기

양방향 연결 리스트의 잘 알려지지 않은 장점 : 한번 삭제했던 원소를 제자리에 쉽게 돌려 놓을 수 있다는 것.

```
연결 리스트에서 노드를 삭제하고 다시 추가하기

// node 이전/이후 노드의 포인터를 바꿔서 node를 리스트에서 삭제
void deleteNode(ListNode* node){
	node->prev->next = node->next;
	node->next->prev = node->prev;
}

// node 이전/이후 노드의 포인터를 바꿔서 자기 자신을 다시 리스트에 삽입
void recoverNode(ListNode* node){
	node->prev->next = node;
	node->next->prev = nonde;
}
```
여기서 바꾼 것은 node의 이전/이후 노드의 포인터 뿐으로, node에 들어있는 정보는 변하지 않았다.
node의 포인터들은 원래 자기가 들어가 있던 위치를 알고 있기 때문에, recoverNode()처럼 node에 대해서만 알고 있어도 원래 리스트에 쉽게 다시 삽입 가능.

주의!! 이전 노드나 이후 노드 또한 삭제된 상태에서 수행하면 리스트를 망가뜨린다. 항상 삭제한 순서의 반대로 복구가 이루어질 때만 사용가능.

### 동적 배열과 연결 리스트의 비교

둘의 가장 큰 차이점은 삽입과 삭제 그리고 임의의 원소에 접근하는데 드는 시간.

삽입과 삭제를 할 일이 없거나, 배열의 끝에서만 하면 될 경우 : 동적배열이 거의 항상 더 좋은 선택!
임의의 원소에 빠르게 접근할 수 있을 뿐더러, 원소들이 메모리에 연속해 배치되어 있다는 점이 CPU 캐시의 효율도 더 높여주기 때문이다.
만약 임의의 원소를 접근하는 것이 아니라 모든 원소들을 순회하며 삽입과 삭제를 한다면 연결리스트가 좋은 선택!

>동적 배열과 연결리스트 비교 표

작업|동적배열|연결리스트
----|--------|----------
이전원소/다음원소 찾기|O(1)|O(1)
맨 뒤에 원소 추가/삭제|O(1)|O(1)
맨 뒤 이외의 위치에 원소 추가/삭제|O(n)|O(1)
임의의 위치의 원소 찾기|O(1)|O(n)
크기 구하기|O(1)|O(n)혹은 구현에 따라O(1)


